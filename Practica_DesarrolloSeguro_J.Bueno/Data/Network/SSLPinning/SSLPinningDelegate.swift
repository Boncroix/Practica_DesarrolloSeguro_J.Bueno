//
//  SSLPinningDelegate.swift
//  Practica_DesarrolloSeguro_J.Bueno
//
//  Created by Jose Bueno Cruz on 23/5/24.
//

import Foundation
import CommonCrypto
import CryptoKit

// MARK: - SSLPinningDelegate
class SSLPinningDelegate: NSObject {
    private let crypto: Crypto
    private let selaledDataBoxArray: [UInt8] = [0x93-0x1D,0x74-0x0D,0x58-0x11,0xC3-0x4C,0xC8-0x5C,0x4F+0x18,0x34-0x09,0x60-0x2F,0x49-0x06,0x06+0x4E,0x3C-0x05,0x9C-0x31,0x4A+0x05,0x3C+0x35,0x9A-0x48,0x2D+0x1A,0xC8-0x5C,0x48+0x00,0x8A-0x1A,0x79-0x0D,0xD3-0x60,0x3B+0x15,0x60-0x2D,0x00+0x38,0x3C+0x1D,0x14+0x5D,0x82-0x19,0x54+0x13,0x1F+0x4F,0xC3-0x5C,0x5F-0x1A,0x6F-0x16,0x39-0x06,0xAB-0x3F,0x96-0x44,0x2F+0x07,0x14+0x58,0x79-0x34,0x35-0x02,0x6B-0x21,0xCF-0x56,0x5F-0x08,0x55+0x13,0x1C+0x53,0x1D+0x49,0x2C+0x3A,0x12+0x1F,0x63+0x04,0x1D+0x2C,0x68-0x1C,0x5E-0x19,0xA1-0x3D,0x1E+0x0D,0x9E-0x4A,0x06+0x61,0x03+0x35,0x87-0x42,0x0F+0x59,0x23+0x35,0xD1-0x58,0x4C+0x08,0x6C-0x1C,0x2B+0x36,0x5C-0x25,0x04+0x2E,0x90-0x47,0x04+0x60,0x28+0x0D,0xBC-0x50,0x3B+0x0F,0x78-0x27,0xBF-0x57,0x85-0x2B,0x8F-0x47,0x34+0x19,0x01+0x51,0x03+0x61,0x73-0x03,0x6C+0x09,0x11+0x21,0x3F-0x08,0x78-0x27,0x80-0x3C,0x64-0x1C,0x17+0x36,0xA9-0x46,0x7F-0x3C,0x38-0x07,0x6A-0x14,0xBC-0x44,0x3F+0x27,0x69-0x27,0xA4-0x4E,0x96-0x2F,0x08+0x4E,0x2B+0x22]
    
    override init() {
        crypto = Crypto(selaledDataBox: selaledDataBoxArray)
    }
}

// MARK: - Extension URLSessionDelegate functions
extension SSLPinningDelegate: URLSessionDelegate {
    
    // MARK: Functions
    func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
        
        // Get server trust
        guard let serverTrust = challenge.protectionSpace.serverTrust else {
            completionHandler(.cancelAuthenticationChallenge, nil)
            print("SSLPinning error: server didn't present trust")
            return
        }
        
        // Get Certificates
        let serverCertificates: [SecCertificate]?
        serverCertificates = SecTrustCopyCertificateChain(serverTrust) as? [SecCertificate]
        guard let serverCertificate = serverCertificates?.first else {
            completionHandler(.cancelAuthenticationChallenge, nil)
            print("SSLPinning error: server certificate is nil")
            return
        }
        
        // Get Public Key
        guard let serverPublicKey = SecCertificateCopyKey(serverCertificate) else {
            completionHandler(.cancelAuthenticationChallenge, nil)
            print("SSLPinning error: server public key is nil")
            return
        }
        
        // Transform Public Key
        guard let serverPublicKeyRep = SecKeyCopyExternalRepresentation(serverPublicKey, nil) else {
            completionHandler(.cancelAuthenticationChallenge, nil)
            print("SSLPinning error: unable to convert server public key to data")
            return
        }
        
        // Tansform Data
        let serverPublicKeyData = serverPublicKeyRep as Data
        let serverHashBase64 = sha256CryptoKit(data: serverPublicKeyData)
        
        // Check that the local public key is the same as that of the server
        if serverHashBase64 == self.crypto.getDecrypted() {
            // Server Validated
            completionHandler(.useCredential, URLCredential(trust: serverTrust))
        } else {
            // Server public key doesnt match
            completionHandler(.cancelAuthenticationChallenge, nil)
            print("SSLPinning error: server public key doesn't match")
        }
    }
    
    func sha256CryptoKit(data: Data) -> String {
        let hash = SHA256.hash(data: data)
        return Data(hash).base64EncodedString()
    }
}
